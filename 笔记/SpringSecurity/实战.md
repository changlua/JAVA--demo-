[toc]

# 项目地址

![image-20220326095320350](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260953434.png)  

# 一、第一个SpringSecurity项目（基于FormLogin）

## 环境搭建

准备环境：

+ spring-boot-starter-parent：2.6.4。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

准备一个接口：

```java
@RestController
public class HelloController {

    @RequestMapping("/hello")
    public String hello(){
        return "hello";
    }

}
```

当我们访问/hello接口时，此时就会被SpringSecurity的表单所拦截。

![image-20220322153757918](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260837654.png)    

输入用户名：user，以及控制台给我们打印的密码即可认证通过。

![image-20220322153819737](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260837654.png)    

## 原因分析

### 流程分析

![image-20220111100643506](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260837654.png)  

1. 请求 /hello 接口，在引入 spring security 之后会先经过一些列过滤器
2. 在请求到达 FilterSecurityInterceptor时，发现请求并未认证。请求拦截下来，并抛出 AccessDeniedException 异常。
3. 抛出 AccessDeniedException 的异常会被 ExceptionTranslationFilter 捕获，这个 Filter 中会调用 LoginUrlAuthenticationEntryPoint#commence 方法给客户端返回 302，要求客户端进行重定向到 /login 页面。
4. 客户端发送 /login 请求。
5. /login 请求会再次被拦截器中 DefaultLoginPageGeneratingFilter 拦截到，并在拦截器中返回生成登录页面。

**就是通过这种方式，Spring Security 默认过滤器中生成了登录页面，并返回！**

### 个人梳理

> 流程：引入Spring-security依赖之后，由于我们没有任何配置修改，那么SpringBoot对于Security的自动配置即可生效，默认会有一个登录页面的过滤器，默认配置是对所有的接口都要进行认证，所以就会被拦截，此时接口就会返回302也就是重定向到/login地址，自然要进行登录操作。
>
> 本质认证规则：登录成功之后，就会建立一个session在服务器端，并且会将session的key返回给前台（通过响应头设置Set-Cookie: 
>
> JSESSIONID=86E5721100475A5E99D61AE5984C14A4; Path=/; HttpOnly属性），之后再去访问时携带session id（cookie）来进行校验自然会通过接着此时就能够访问接口。
>
> 三个疑问如下：

**解决疑问1**：引入springboot-securty之后无任何配置就出现一个表单认证，拦截我们的接口

两个核心配置类：

WebSecurityConfiguration：构建Spring的bean对象

```java
@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)
public Filter springSecurityFilterChain() throws Exception {
    boolean hasConfigurers = this.webSecurityConfigurers != null && !this.webSecurityConfigurers.isEmpty();
    boolean hasFilterChain = !this.securityFilterChains.isEmpty();
    Assert.state(!(hasConfigurers && hasFilterChain),
                 "Found WebSecurityConfigurerAdapter as well as SecurityFilterChain. Please select just one.");
    if (!hasConfigurers && !hasFilterChain) {
        WebSecurityConfigurerAdapter adapter = this.objectObjectPostProcessor
            .postProcess(new WebSecurityConfigurerAdapter() {
            });
        this.webSecurity.apply(adapter);
    }
    //初始化添加security-filter到proxy中
    for (SecurityFilterChain securityFilterChain : this.securityFilterChains) {
        this.webSecurity.addSecurityFilterChainBuilder(() -> securityFilterChain);
        for (Filter filter : securityFilterChain.getFilters()) {
            if (filter instanceof FilterSecurityInterceptor) {
                this.webSecurity.securityInterceptor((FilterSecurityInterceptor) filter);
                break;
            }
        }
    }
    for (WebSecurityCustomizer customizer : this.webSecurityCustomizers) {
        customizer.customize(this.webSecurity);
    }
    return this.webSecurity.build();
}
```

SpringBootWebSecurityConfiguration：SpringBoot级别的自动装配

```java
@Bean
@Order(SecurityProperties.BASIC_AUTH_ORDER)
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
    http.authorizeRequests()  //开启权限认证管理
        .anyRequest()  //对所有的请求
        .authenticated()   //认证之后才能进行访问
        .and()             
        .formLogin().and().httpBasic(); //支持表单认证和HttpBasic认证
    return http.build();
}
```

若是我们想要自定义spring-security，可以通过在自己的包路径下改写WebSecurityConfigurerAdapter(抽象类)或SecurityFilterChain(接口)，一般推荐抽象类。

**解决疑问2**：为什么发送一个请求时最终会进入到一个登录页

原因：发送/hello请求时会经过一个过滤器，由于其认证没有通过，最终会在FilterSecurityInterceptor被拦截下并抛出异常被ExceptionTransicationFilter处理向客户端发送了一个403重定向请求到/login，最终就会出现登录页了。

+ DefaultLoginPageGeneratingFilter  =>   /login

**疑问3**：默认登录用户名和密码是如何校验的呢？

+ 底层通过`UsernamePasswordAuthenticationFilter`这个过滤器中(使用ProviderManager执行的authenticate方法)最后间接调用的InMemoryUserDetailsManager这个管理器(实现UserDetailsService接口的`loadUserByUsername`)。
+ 最终通过loadUserByUsername获取到用户对象。

## 自行配置Form登录的用户名及密码

我们可以在application.properties中配置form登录的信息来对Sprinng-Security中的默认内容(用户名、密码、角色)进行修改，对应当前登录用户的名称、密码以及角色。

```properties
spring.security.user.name=root
spring.security.user.password=123456
spring.security.user.roles=admin,user
```

---

## 自定义资源权限规则

> 搭配项目

```java
/**
 * @ClassName WebSecurityConfig
 * @Author ChangLu
 * @Date 3/22/2022 3:59 PM
 * @Description Security配置类
 */
@Configuration
public class WebSecurityConfig  extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()  //获取url注册器对象
                .antMatchers("/index").permitAll()  //代表放行该资源,该资源为公共资源 无需认证和授权可以直接访问
                .anyRequest().authenticated() //其他所有请求,必须认证之后才能访问
                .and().formLogin();   //代表开启表单认证
    }
}
```

```markdown
# 说明
- permitAll() 代表放行该资源,该资源为公共资源 无需认证和授权可以直接访问
- anyRequest().authenticated() 代表所有请求,必须认证之后才能访问
- formLogin() 代表开启表单认证
## 注意: 放行资源必须放在所有认证请求之前!
```

接着添加一个/index接口，只放行该接口：

![image-20220322160647849](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203221606903.png)  

```java
@RequestMapping("/index")
public String index(){
    return "index";
}
```

接着运行效果：

/index：允许访问。

/hello：需要form登录才可。

---

# 二、自定义认证（基于FormLogin）

form login登录的默认配置：

```
username
password
POST  接口uri：/login
```

## 自定义资源权限规则

- /index  公共资源
- /hello .... 受保护资源 权限管理

在项目中添加如下配置就可以实现对资源权限规则设定:

```java
@Configuration
public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
                .mvcMatchers("/index").permitAll()
                .anyRequest().authenticated()
                .and().formLogin();
    }
}
```

![image-20220113050533209](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241606753.png)  

```markdown
# 说明
- permitAll() 代表放行该资源,该资源为公共资源 无需认证和授权可以直接访问
- anyRequest().authenticated() 代表所有请求,必须认证之后才能访问
- formLogin() 代表开启表单认证
## 注意: 放行资源必须放在所有认证请求之前!
```

## 自定义登录界面

- 引入模板依赖

  ```xml
  <!--thymeleaf-->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
  </dependency>
  ```

- 定义登录页面 controller

  ```java
  @Controller
  public class LoginController {
  
      @RequestMapping("/login.html")
      public String login() {
          return "login";
      }
  }
  ```

- 在 templates 中定义登录界面

  ```html
  <!DOCTYPE html>
  <html lang="en" xmlns:th="https://www.thymeleaf.org">
  <head>
      <meta charset="UTF-8">
      <title>登录</title>
  </head>
  <body>
  <h1>用户登录</h1>
  <form method="post" th:action="@{/doLogin}">
      用户名:<input name="uname" type="text"/><br>
      密码:<input name="passwd" type="password"/><br>
      <input type="submit" value="登录"/>
  </form>
  </body>
  </html>
  ```

  **需要注意的是**

  - 登录表单 method 必须为 `post`，action 的请求路径为 `/doLogin`
  - 用户名的 name 属性为 `uname`
  - 密码的 name 属性为 `passwd`

- 配置 Spring Security 配置类

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
      @Override
      protected void configure(HttpSecurity http) throws Exception {
           http.authorizeHttpRequests()
                  .mvcMatchers("/login.html").permitAll()
                  .mvcMatchers("/index").permitAll()
                  .anyRequest().authenticated()
                  .and()
                  .formLogin()
                  .loginPage("/login.html")
                  .loginProcessingUrl("/doLogin")
                  .usernameParameter("uname")
                  .passwordParameter("passwd")
                  .successForwardUrl("/index") 		 //forward 跳转           注意:不会跳转到之前请求路径
                  //.defaultSuccessUrl("/index")   //redirect 重定向    注意:如果之前请求路径,会有优先跳转之前请求路径
                  .failureUrl("/login.html")
                  .and()
                  .csrf().disable();//这里先关闭 CSRF
      }
  }
  ```

  - successForwardUrl 、defaultSuccessUrl 这两个方法都可以实现成功之后跳转
    - successForwardUrl  默认使用 `forward `跳转      `注意:不会跳转到之前请求路径`
    - defaultSuccessUrl   默认使用 `redirect` 跳转      `注意:如果之前请求路径,会有优先跳转之前请求路径,可以传入第二个参数进行修改`

## 自定义登录成功处理

有时候页面跳转并不能满足我们，特别是在前后端分离开发中就不需要成功之后跳转页面。只需要给前端返回一个 JSON 通知登录成功还是失败与否。这个时候可以通过自定义 `AuthenticationSucccessHandler` 实现

```java
public interface AuthenticationSuccessHandler {

	/**
	 * Called when a user has been successfully authenticated.
	 * @param request the request which caused the successful authentication
	 * @param response the response
	 * @param authentication the <tt>Authentication</tt> object which was created during
	 * the authentication process.
	 */
	void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) throws IOException, ServletException;
}
```

**根据接口的描述信息,也可以得知登录成功会自动回调这个方法，进一步查看它的默认实现，你会发现successForwardUrl、defaultSuccessUrl也是由它的子类实现的**

![image-20220113054514897](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241607784.png)

- 自定义 AuthenticationSuccessHandler 实现

```java
public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        Map<String, Object> result = new HashMap<String, Object>();
        result.put("msg", "登录成功");
        result.put("status", 200);
        response.setContentType("application/json;charset=UTF-8");
        String s = new ObjectMapper().writeValueAsString(result);
        response.getWriter().println(s);
    }
}
```

- 配置 AuthenticationSuccessHandler

```java
@Configuration
public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
                //...
                .and()
                .formLogin()
                //....
                .successHandler(new MyAuthenticationSuccessHandler())
                .failureUrl("/login.html")
                .and()
                .csrf().disable();//这里先关闭 CSRF
    }
}
```

![image-20220113062644363](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241607771.png)

### 显示登录失败信息

为了能更直观在登录页面看到异常错误信息，可以在登录页面中直接获取异常信息。Spring Security 在登录失败之后会将异常信息存储到 `request` 、`session`作用域中 key 为 `SPRING_SECURITY_LAST_EXCEPTION` 命名属性中，源码可以参考 SimpleUrlAuthenticationFailureHandler ：

![image-20220113060257662](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241607788.png)

- 显示异常信息

  ```html
  <!DOCTYPE html>
  <html lang="en" xmlns:th="https://www.thymeleaf.org">
  <head>
      <meta charset="UTF-8">
      <title>登录</title>
  </head>
  <body>
    ....
    <div th:text="${SPRING_SECURITY_LAST_EXCEPTION}"></div>
  </body>
  </html>
  ```

- 配置

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
  
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.authorizeHttpRequests()
                	//..
                  .and()
                  .formLogin()
                  //....
                  //.failureUrl("/login.html")
                  .failureForwardUrl("/login.html")
                  .and()
                  .csrf().disable();//这里先关闭 CSRF
      }
  }
  
  ```

  - failureUrl、failureForwardUrl 关系类似于之前提到的 successForwardUrl 、defaultSuccessUrl 方法
    - failureUrl 失败以后的重定向跳转
    - failureForwardUrl 失败以后的 forward 跳转 `注意:因此获取 request 中异常信息,这里只能使用failureForwardUrl`

### 自定义登录失败处理

和自定义登录成功处理一样，Spring Security 同样为前后端分离开发提供了登录失败的处理，这个类就是  AuthenticationFailureHandler，源码为：

```java
public interface AuthenticationFailureHandler {

	/**
	 * Called when an authentication attempt fails.
	 * @param request the request during which the authentication attempt occurred.
	 * @param response the response.
	 * @param exception the exception which was thrown to reject the authentication
	 * request.
	 */
	void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
			AuthenticationException exception) throws IOException, ServletException;

}
```

**根据接口的描述信息,也可以得知登录失败会自动回调这个方法，进一步查看它的默认实现，你会发现failureUrl、failureForwardUrl也是由它的子类实现的。**

![image-20220113062114741](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241607719.png)  

- 自定义 AuthenticationFailureHandler 实现

```java
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {

    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        Map<String, Object> result = new HashMap<String, Object>();
        result.put("msg", "登录失败: "+exception.getMessage());
        result.put("status", 500);
        response.setContentType("application/json;charset=UTF-8");
        String s = new ObjectMapper().writeValueAsString(result);
        response.getWriter().println(s);
    }
}
```

- 配置 AuthenticationFailureHandler

```java
@Configuration
public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
	              //...
                .and()
                .formLogin()
               	//..
                .failureHandler(new MyAuthenticationFailureHandler())
                .and()
                .csrf().disable();//这里先关闭 CSRF
    }
}
```

![image-20220113062617937](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241607047.png)  

### 注销登录

Spring Security 中也提供了默认的注销登录配置，在开发时也可以按照自己需求对注销进行个性化定制。

- 开启注销登录`默认开启`

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
  @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.authorizeHttpRequests()
                  //...
                  .and()
                  .formLogin()
                  //...
                  .and()
                  .logout()
                  .logoutUrl("/logout")
                  .invalidateHttpSession(true)
                  .clearAuthentication(true)
                  .logoutSuccessUrl("/login.html")
                  .and()
                  .csrf().disable();//这里先关闭 CSRF
      }
  }
  ```

  - 通过 logout() 方法开启注销配置
  - logoutUrl 指定退出登录请求地址，默认是 GET 请求，路径为 `/logout`
  - invalidateHttpSession 退出时是否是 session 失效，默认值为 true
  - clearAuthentication 退出时是否清除认证信息，默认值为 true
  - logoutSuccessUrl 退出登录时跳转地址

- 配置多个注销登录请求

  如果项目中有需要，开发者还可以配置多个注销登录的请求，同时还可以指定请求的方法：

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
  		@Override
      protected void configure(HttpSecurity http) throws Exception {
          http.authorizeHttpRequests()
                  //...
                  .and()
                  .formLogin()
                  //...
                  .and()
                  .logout()
                  .logoutRequestMatcher(new OrRequestMatcher(
                          new AntPathRequestMatcher("/logout1","GET"),
                          new AntPathRequestMatcher("/logout","GET")
                  ))
                  .invalidateHttpSession(true)
                  .clearAuthentication(true)
                  .logoutSuccessUrl("/login.html")
                  .and()
                  .csrf().disable();//这里先关闭 CSRF
      }
  }
  ```

- 前后端分离注销登录配置

  如果是前后端分离开发，注销成功之后就不需要页面跳转了，只需要将注销成功的信息返回前端即可，此时我们可以通过自定义 LogoutSuccessHandler  实现来返回注销之后信息：

  ```java
  public class MyLogoutSuccessHandler implements LogoutSuccessHandler {
      @Override
      public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
          Map<String, Object> result = new HashMap<String, Object>();
          result.put("msg", "注销成功");
          result.put("status", 200);
          response.setContentType("application/json;charset=UTF-8");
          String s = new ObjectMapper().writeValueAsString(result);
          response.getWriter().println(s);
      }
  }
  ```

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.authorizeHttpRequests()
            			//....
                  .and()
                  .formLogin()
   								//...
                  .and()
                  .logout()
                  //.logoutUrl("/logout")
                  .logoutRequestMatcher(new OrRequestMatcher(
                          new AntPathRequestMatcher("/logout1","GET"),
                          new AntPathRequestMatcher("/logout","GET")
                  ))
                  .invalidateHttpSession(true)
                  .clearAuthentication(true)
                  //.logoutSuccessUrl("/login.html")
                  .logoutSuccessHandler(new MyLogoutSuccessHandler())
                  .and()
                  .csrf().disable();//这里先关闭 CSRF
      }
  }
  ```

  ![image-20220113114133687](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241607457.png)  

### 登录用户数据获取

## SecurityContextHolder

###  代码中获取认证之后用户数据

```java
@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String hello() {
      Authentication authentication = SecurityContextHolder
        .getContext().getAuthentication();
      User principal = (User) authentication.getPrincipal();
      System.out.println("身份 :"+principal.getUsername());
      System.out.println("凭证 :"+authentication.getCredentials());
      System.out.println("权限 :"+authentication.getAuthorities());
      return "hello security";
    }
}
```

### 多线程情况下获取用户数据

```java
@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String hello() {
      new Thread(()->{
        Authentication authentication = SecurityContextHolder
          .getContext().getAuthentication();
        User principal = (User) authentication.getPrincipal();
        System.out.println("身份 :"+principal.getUsername());
        System.out.println("凭证 :"+authentication.getCredentials());
        System.out.println("权限 :"+authentication.getAuthorities());
      }).start();
      return "hello security";
    }
}
```

![image-20220113124141492](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241609258.png)  

**可以看到默认策略，是无法在子线程中获取用户信息，如果需要在子线程中获取必须使用第二种策略，默认策略是通过 System.getProperty 加载的，因此我们可以通过增加 VM Options 参数进行修改。**

```properties
-Dspring.security.strategy=MODE_INHERITABLETHREADLOCAL
```

![image-20220113124639102](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241609707.png)  

### 页面上获取用户信息（传统web）

- 引入依赖

  ```xml
  <dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity5</artifactId>
    <version>3.0.4.RELEASE</version>
  </dependency>
  ```

- 页面加入命名空间

  ```html
  <html lang="en" xmlns:th="https://www.thymeleaf.org" 
  xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
  ```

- 页面中使用

  ```html
  <!--获取认证用户名-->
  <ul>
    <li sec:authentication="principal.username"></li>
    <li sec:authentication="principal.authorities"></li>
    <li sec:authentication="principal.accountNonExpired"></li>
    <li sec:authentication="principal.accountNonLocked"></li>
    <li sec:authentication="principal.credentialsNonExpired"></li>
  </ul>
  ```

## 自定义认证数据源

### 配置全局 AuthenticationManager

https://spring.io/guides/topicals/spring-security-architecture

- 默认的全局 AuthenticationManager

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
    @Autowired
    public void initialize(AuthenticationManagerBuilder builder) {
      //builder..
    }
  }
  ```

  - springboot 对 security 进行自动配置时自动在工厂中创建一个全局AuthenticationManager

  **总结**

  1. 默认自动配置创建全局AuthenticationManager 默认找当前项目中是否存在自定义 UserDetailService 实例 自动将当前项目 UserDetailService 实例设置为数据源
  2. 默认自动配置创建全局AuthenticationManager 在工厂中使用时直接在代码中注入即可

- 自定义全局 AuthenticationManager

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(AuthenticationManagerBuilder builder) {
    	//builder ....
    }
  }
  ```

  - 自定义全局 AuthenticationManager

  **总结**

  1. 一旦通过 configure 方法自定义 AuthenticationManager实现 就回将工厂中自动配置AuthenticationManager 进行覆盖
  2. 一旦通过 configure 方法自定义 AuthenticationManager实现 需要在实现中指定认证数据源对象 UserDetaiService 实例
  3. 一旦通过 configure 方法自定义 AuthenticationManager实现 这种方式创建AuthenticationManager对象工厂内部本地一个 AuthenticationManager 对象 不允许在其他自定义组件中进行注入

- 用来在工厂中暴露自定义AuthenticationManager 实例

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
      
      public UserDetailsService userDetailsService(){
          InMemoryUserDetailsManager userDetailsService = new InMemoryUserDetailsManager();
          userDetailsService.createUser(User.withUsername("ccc").password("{noop}789").roles("admin,user").build());
          return userDetailsService;
      }
    
      //1.自定义AuthenticationManager  推荐  并没有在工厂中暴露出来
      @Override
      public void configure(AuthenticationManagerBuilder builder) throws Exception {
          System.out.println("自定义AuthenticationManager: " + builder);
          builder.userDetailsService(userDetailsService());//配置自定义的认证数据源
      }
  
      //作用: 用来将自定义AuthenticationManager在工厂中进行暴露,可以在任何位置注入
      @Override
      @Bean
      public AuthenticationManager authenticationManagerBean() throws Exception {
          return super.authenticationManagerBean();
      }
  }
  
  ```

### 自定义内存数据源

```java
@Configuration
public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {

    @Bean
    public UserDetailsService userDetailsService(){
        InMemoryUserDetailsManager inMemoryUserDetailsManager
                = new InMemoryUserDetailsManager();
        UserDetails u1 = User.withUsername("zhangs")
                .password("{noop}111").roles("USER").build();
        inMemoryUserDetailsManager.createUser(u1);
        return inMemoryUserDetailsManager;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) 
      throws Exception {
        auth.userDetailsService(userDetailsService());
    }  	
}
```

### 自定义数据库数据源

- 设计表结构

  ```sql
  -- 用户表
  CREATE TABLE `user`
  (
      `id`                    int(11) NOT NULL AUTO_INCREMENT,
      `username`              varchar(32)  DEFAULT NULL,
      `password`              varchar(255) DEFAULT NULL,
      `enabled`               tinyint(1) DEFAULT NULL,
      `accountNonExpired`     tinyint(1) DEFAULT NULL,
      `accountNonLocked`      tinyint(1) DEFAULT NULL,
      `credentialsNonExpired` tinyint(1) DEFAULT NULL,
      PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
  -- 角色表
  CREATE TABLE `role`
  (
      `id`      int(11) NOT NULL AUTO_INCREMENT,
      `name`    varchar(32) DEFAULT NULL,
      `name_zh` varchar(32) DEFAULT NULL,
      PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
  -- 用户角色关系表
  CREATE TABLE `user_role`
  (
      `id`  int(11) NOT NULL AUTO_INCREMENT,
      `uid` int(11) DEFAULT NULL,
      `rid` int(11) DEFAULT NULL,
      PRIMARY KEY (`id`),
      KEY   `uid` (`uid`),
      KEY   `rid` (`rid`)
  ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
  ```

- 插入测试数据

  ```sql
  -- 插入用户数据
  BEGIN;
    INSERT INTO `user`
    VALUES (1, 'root', '{noop}123', 1, 1, 1, 1);
    INSERT INTO `user`
    VALUES (2, 'admin', '{noop}123', 1, 1, 1, 1);
    INSERT INTO `user`
    VALUES (3, 'blr', '{noop}123', 1, 1, 1, 1);
  COMMIT;
  -- 插入角色数据
  BEGIN;
    INSERT INTO `role`
    VALUES (1, 'ROLE_product', '商品管理员');
    INSERT INTO `role`
    VALUES (2, 'ROLE_admin', '系统管理员');
    INSERT INTO `role`
    VALUES (3, 'ROLE_user', '用户管理员');
  COMMIT;
  -- 插入用户角色数据
  BEGIN;
    INSERT INTO `user_role`
    VALUES (1, 1, 1);
    INSERT INTO `user_role`
    VALUES (2, 1, 2);
    INSERT INTO `user_role`
    VALUES (3, 2, 2);
    INSERT INTO `user_role`
    VALUES (4, 3, 3);
  COMMIT;
  ```

- 项目中引入依赖

  ```xml
  <dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
  </dependency>
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.38</version>
  </dependency>
  <dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.7</version>
  </dependency>
  ```

- 配置 springboot 配置文件

  ```properties
  # datasource
  spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
  spring.datasource.driver-class-name=com.mysql.jdbc.Driver
  spring.datasource.url=jdbc:mysql://localhost:3306/security?characterEncoding=UTF-8&useSSL=false
  spring.datasource.username=root
  spring.datasource.password=root
  
  # mybatis
  mybatis.mapper-locations=classpath:com/baizhi/mapper/*.xml
  mybatis.type-aliases-package=com.baizhi.entity
  
  # log
  logging.level.com.baizhi=debug
  ```

- 创建 entity

  - 创建 user 对象

    ```java
    public class User  implements UserDetails {
        private Integer id;
        private String username;
        private String password;
        private Boolean enabled;
        private Boolean accountNonExpired;
        private Boolean accountNonLocked;
        private Boolean credentialsNonExpired;
        private List<Role> roles = new ArrayList<>();
    
        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            List<GrantedAuthority> grantedAuthorities = new ArrayList<>();
            roles.forEach(role->grantedAuthorities.add(new SimpleGrantedAuthority(role.getName())));
            return grantedAuthorities;
        }
    
        @Override
        public String getPassword() {
            return password;
        }
    
        @Override
        public String getUsername() {
            return username;
        }
    
        @Override
        public boolean isAccountNonExpired() {
            return accountNonExpired;
        }
    
        @Override
        public boolean isAccountNonLocked() {
            return accountNonLocked;
        }
    
        @Override
        public boolean isCredentialsNonExpired() {
            return credentialsNonExpired;
        }
    
        @Override
        public boolean isEnabled() {
            return enabled;
        }
    		//get/set....
    }
    ```

  - 创建 role 对象

    ```java
    public class Role {
        private Integer id;
        private String name;
        private String nameZh;
      	//get set..
    }
    ```

- 创建 UserDao 接口

  ```java
  @Mapper
  public interface UserDao {
      //根据用户名查询用户
      User loadUserByUsername(String username);
    	
    	//根据用户id查询角色
    	List<Role> getRolesByUid(Integer uid);
  }
  ```

- 创建 UserMapper 实现

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="com.baizhi.dao.UserDao">
      <!--查询单个-->
      <select id="loadUserByUsername" resultType="User">
          select id,
                 username,
                 password,
                 enabled,
                 accountNonExpired,
                 accountNonLocked,
                 credentialsNonExpired
          from user
          where username = #{username}
      </select>
  
      <!--查询指定行数据-->
      <select id="getRolesByUid" resultType="Role">
          select r.id,
                 r.name,
                 r.name_zh nameZh
          from role r,
               user_role ur
          where r.id = ur.rid
            and ur.uid = #{uid}
      </select>
  </mapper>
  ```

- 创建 UserDetailService 实例

  ```java
  @Component
  public class MyUserDetailService implements UserDetailsService {
  
      private  final UserDao userDao;
  
      @Autowired
      public MyUserDetailService(UserDao userDao) {
          this.userDao = userDao;
      }
  
      @Override
      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
          User user = userDao.loadUserByUsername(username);
          if(ObjectUtils.isEmpty(user))throw new RuntimeException("用户不存在");
          user.setRoles(userDao.getRolesByUid(user.getId()));
          return user;
      }
  }
  ```

- 配置 authenticationManager 使用自定义UserDetailService

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
    
      private final UserDetailsService userDetailsService;
  
      @Autowired
      public WebSecurityConfigurer(UserDetailsService userDetailsService) {
          this.userDetailsService = userDetailsService;
      }
  
      @Override
      protected void configure(AuthenticationManagerBuilder builder) throws Exception {
          builder.userDetailsService(userDetailsService);
      }
    
    	
    	@Override
      protected void configure(HttpSecurity http) throws Exception {
        //web security..
      }
  }
  ```

- 启动测试即可

## 添加认证验证码

### 配置验证码

```xml
<dependency>
  <groupId>com.github.penggle</groupId>
  <artifactId>kaptcha</artifactId>
  <version>2.3.2</version>
</dependency>
```

```java
@Configuration
public class KaptchaConfig {
    @Bean
    public Producer kaptcha() {
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width", "150");
        properties.setProperty("kaptcha.image.height", "50");
        properties.setProperty("kaptcha.textproducer.char.string", "0123456789");
        properties.setProperty("kaptcha.textproducer.char.length", "4");
        Config config = new Config(properties);
        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
        defaultKaptcha.setConfig(config);
        return defaultKaptcha;
    }
}
```

### 传统 web 开发

- 生成验证码 controller

  ```java
  @Controller
  public class KaptchaController {
      private final Producer producer;
  
      @Autowired
      public KaptchaController(Producer producer) {
          this.producer = producer;
      }
  
      @GetMapping("/vc.jpg")
      public void getVerifyCode(HttpServletResponse response, HttpSession session) throws IOException {
          response.setContentType("image/png");
          String code = producer.createText();
          session.setAttribute("kaptcha", code);//可以更换成 redis 实现
          BufferedImage bi = producer.createImage(code);
          ServletOutputStream os = response.getOutputStream();
          ImageIO.write(bi, "jpg", os);
      }
  }
  ```

- 自定义验证码异常类

  ```java
  public class KaptchaNotMatchException extends AuthenticationException {
  
      public KaptchaNotMatchException(String msg) {
          super(msg);
      }
  
      public KaptchaNotMatchException(String msg, Throwable cause) {
          super(msg, cause);
      }
  }
  ```

- 自定义filter验证验证码

  ```java
  public class KaptchaFilter extends UsernamePasswordAuthenticationFilter {
  
      public static final String KAPTCHA_KEY = "kaptcha";//默认值
      private String kaptcha = KAPTCHA_KEY;
  
      public String getKaptcha() {
          return kaptcha;
      }
  
      public void setKaptcha(String kaptcha) {
          this.kaptcha = kaptcha;
      }
  
      @Override
      public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
          //1.判断是否是 post 方式
          if (request.getMethod().equals("POST")) {
              throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
          }
          //2.获取验证码
          String kaptcha = request.getParameter(getKaptcha());
          String sessionKaptcha = (String) request.getSession().getAttribute("kaptcha");
          if (!ObjectUtils.isEmpty(kaptcha) && !ObjectUtils.isEmpty(sessionKaptcha) &&
                  kaptcha.equalsIgnoreCase(sessionKaptcha)) {
              return super.attemptAuthentication(request, response);
          }
          throw new KaptchaNotMatchException("验证码输入错误!");
      }
  }
  ```

- 放行以及配置验证码 filter

  ```java
  @Configuration
  public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
  
      private final UserDetailsService userDetailsService;
  
      @Autowired
      public WebSecurityConfigurer(UserDetailsService userDetailsService) {
          this.userDetailsService = userDetailsService;
      }
  
      @Override
      protected void configure(AuthenticationManagerBuilder builder) throws Exception {
          builder.userDetailsService(userDetailsService);
      }
  
      @Override
      @Bean
      public AuthenticationManager authenticationManagerBean() throws Exception {
          return super.authenticationManagerBean();
      }
  
      @Bean
      public KaptchaFilter kaptchaFilter() throws Exception {
          KaptchaFilter kaptchaFilter = new KaptchaFilter();
          //指定接收验证码请求参数名
          kaptchaFilter.setKaptcha("kaptcha");
          //指定认证管理器
          kaptchaFilter.setAuthenticationManager(authenticationManagerBean());
          //指定认证成功和失败处理
          kaptchaFilter.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());
          kaptchaFilter.setAuthenticationFailureHandler(new MyAuthenticationFailureHandler());
          //指定处理登录
          kaptchaFilter.setFilterProcessesUrl("/doLogin");
          kaptchaFilter.setUsernameParameter("uname");
          kaptchaFilter.setPasswordParameter("passwd");
          return kaptchaFilter;
      }
  
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.authorizeHttpRequests()
                  .mvcMatchers("/vc.jpg").permitAll()
                  .mvcMatchers("/login.html").permitAll()
                  .anyRequest().authenticated()
                  .and()
                  .formLogin()
                  .loginPage("/login.html")
                	...
          http.addFilterAt(kaptchaFilter(), UsernamePasswordAuthenticationFilter.class);
      }
  }
  ```

- 登录页面添加验证码

  ```html
  <form method="post" th:action="@{/doLogin}">
      用户名:<input name="uname" type="text"/><br>
      密码:<input name="passwd" type="password"/><br>
      验证码: <input name="kaptcha" type="text"/> <img alt="" th:src="@{/vc.jpg}"><br>
      <input type="submit" value="登录"/>
  </form>
  ```

### 前后端分离开发

- 生成验证码 controller

  ```java
  @RestController
  public class KaptchaController {
      private final Producer producer;
  
      @Autowired
      public KaptchaController(Producer producer) {
          this.producer = producer;
      }
  
      @GetMapping("/vc.png")
      public String getVerifyCode(HttpSession session) throws IOException {
          //1.生成验证码
          String code = producer.createText();
          session.setAttribute("kaptcha", code);//可以更换成 redis 实现
          BufferedImage bi = producer.createImage(code);
          //2.写入内存
          FastByteArrayOutputStream fos = new FastByteArrayOutputStream();
          ImageIO.write(bi, "png", fos);
          //3.生成 base64
          return Base64.encodeBase64String(fos.toByteArray());
      }
  }
  ```

- 定义验证码异常类

  ```java
  public class KaptchaNotMatchException extends AuthenticationException {
  
      public KaptchaNotMatchException(String msg) {
          super(msg);
      }
  
      public KaptchaNotMatchException(String msg, Throwable cause) {
          super(msg, cause);
      }
  }
  ```

- 在自定义LoginKaptchaFilter中加入验证码验证

  ```java
  //自定义 filter
  public class LoginKaptchaFilter extends UsernamePasswordAuthenticationFilter {
  
      public static final String FORM_KAPTCHA_KEY = "kaptcha";
  
      private String kaptchaParameter = FORM_KAPTCHA_KEY;
  
      public String getKaptchaParameter() {
          return kaptchaParameter;
      }
  
      public void setKaptchaParameter(String kaptchaParameter) {
          this.kaptchaParameter = kaptchaParameter;
      }
  
      @Override
      public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
          if (!request.getMethod().equals("POST")) {
              throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
          }
          try {
              //1.获取请求数据
              Map<String, String> userInfo = new ObjectMapper().readValue(request.getInputStream(), Map.class);
              String kaptcha = userInfo.get(getKaptchaParameter());//用来获取数据中验证码
              String username = userInfo.get(getUsernameParameter());//用来接收用户名
              String password = userInfo.get(getPasswordParameter());//用来接收密码
              //2.获取 session 中验证码
              String sessionVerifyCode = (String) request.getSession().getAttribute("kaptcha");
              if (!ObjectUtils.isEmpty(kaptcha) && !ObjectUtils.isEmpty(sessionVerifyCode) &&
                      kaptcha.equalsIgnoreCase(sessionVerifyCode)) {
                  //3.获取用户名 和密码认证
                  UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
                  setDetails(request, authRequest);
                  return this.getAuthenticationManager().authenticate(authRequest);
              }
          } catch (IOException e) {
              e.printStackTrace();
          }
          throw new KaptchaNotMatchException("验证码不匹配!");
      }
  }
  ```

- 配置

  ```java
  @Configuration
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
  
      //自定义内存数据源
      @Bean
      public UserDetailsService userDetailsService() {
          InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
          inMemoryUserDetailsManager.createUser(User.withUsername("root").password("{noop}123").roles("admin").build());
          return inMemoryUserDetailsManager;
      }
  
      @Override
      protected void configure(AuthenticationManagerBuilder auth) throws Exception {
          auth.userDetailsService(userDetailsService());
      }
  
      @Override
      @Bean
      public AuthenticationManager authenticationManagerBean() throws Exception {
          return super.authenticationManagerBean();
      }
  
      //配置
      @Bean
      public LoginKaptchaFilter loginKaptchaFilter() throws Exception {
          LoginKaptchaFilter loginKaptchaFilter = new LoginKaptchaFilter();
          //1.认证 url
          loginKaptchaFilter.setFilterProcessesUrl("/doLogin");
          //2.认证 接收参数
          loginKaptchaFilter.setUsernameParameter("uname");
          loginKaptchaFilter.setPasswordParameter("passwd");
          loginKaptchaFilter.setKaptchaParameter("kaptcha");
          //3.指定认证管理器
          loginKaptchaFilter.setAuthenticationManager(authenticationManagerBean());
          //4.指定成功时处理
          loginKaptchaFilter.setAuthenticationSuccessHandler((req, resp, authentication) -> {
              Map<String, Object> result = new HashMap<String, Object>();
              result.put("msg", "登录成功");
              result.put("用户信息", authentication.getPrincipal());
              resp.setContentType("application/json;charset=UTF-8");
              resp.setStatus(HttpStatus.OK.value());
              String s = new ObjectMapper().writeValueAsString(result);
              resp.getWriter().println(s);
          });
          //5.认证失败处理
          loginKaptchaFilter.setAuthenticationFailureHandler((req, resp, ex) -> {
              Map<String, Object> result = new HashMap<String, Object>();
              result.put("msg", "登录失败: " + ex.getMessage());
              resp.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
              resp.setContentType("application/json;charset=UTF-8");
              String s = new ObjectMapper().writeValueAsString(result);
              resp.getWriter().println(s);
          });
          return loginKaptchaFilter;
      }
  
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.authorizeRequests()
                  .mvcMatchers("/vc.jpg").permitAll()
                  .anyRequest().authenticated()
                  .and()
                  .formLogin()
                  .and()
                  .exceptionHandling()
                  .authenticationEntryPoint((req, resp, ex) -> {
                      resp.setContentType("application/json;charset=UTF-8");
                      resp.setStatus(HttpStatus.UNAUTHORIZED.value());
                      resp.getWriter().println("必须认证之后才能访问!");
                  })
                  .and()
                  .logout()
                  .and()
                  .csrf().disable();
  
          http.addFilterAt(loginKaptchaFilter(), UsernamePasswordAuthenticationFilter.class);
      }
  
  ```

- 测试验证



# 三、传统web账号登录、注销（基于session）



## 完整demo

描述：

```java
通过使用session来存储用户信息
基于传统web形式(前后端不分离)账号(用户名、密码、验证码)的登录、注销
认证数据源：通过数据库来进行校验用户
```

### 测试

> 前提说明

![image-20220324140836753](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241408784.png)  

页面1：用户登录页

![image-20220324140756750](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241408846.png)  

页面2：注销页面

![image-20220324140925897](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241409941.png)  

> 测试

**①任意访问一个错误网址，跳转到登录页**

例如：http://localhost:8083/logi。效果：重定向。

![image-20220324141357082](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241413126.png)  

**②登录失败：验证码有误。**效果：重定向。

![image-20220324141649914](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241416980.png)  

**③登录失败：密码错误。**效果：重定向。

![image-20220324141902315](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241419375.png)  

**④登录成功。**效果：重定向到注销页面，显示用户的信息以及角色。

![image-20220324142027884](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241420963.png)  

**⑤登录成功后，访问需认证资源。**效果：可访问。

![image-20220324142517520](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241425552.png)  

**⑤登录成功后，点击注销。**效果：退出登录重定向到登录页面。

![image-20220324142252610](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241422680.png)  

### 思路

> 传统web：都是返回视图，对于验证码则是直接返回图片类型(设置contentType为image/png，通过流来写入返回)。

未加验证码前，用户登录都是走的UsernamePasswordAuthenticationFilter，我们只需要自定义其中的认证数据源loadUserByUsername即可。

加验证码后，自定义KaptchaFilter中的认证方法（重写父类）来进行验证码认证，验证码通过之后会走其父类的认证方法继续认证用户。

![image-20220324145508607](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241455685.png)  

### 代码示例

![image-20220324145629498](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241456557.png)  

#### 配置

application.properties

```properties
# 服务器端口号
server.port=8083
# datasource
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/security?characterEncoding=UTF-8&useSSL=false
spring.datasource.username=root
spring.datasource.password=123456

# mybatis
mybatis.mapper-locations=classpath:com/changlu/mapper/*.xml
mybatis.type-aliases-package=com.changlu.springsecuritydemo3web.entity
# mybatis log开启
logging.level.com.changlu.springsecuritydemo3web=debug

# 关闭thymeleaf缓存
spring.thymeleaf.cache=false
# 下面是thymeleaf的默认配置
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.mode=HTML
```

pom.xml：springboot 2.6.4

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!--    thymeleaf    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

<!--thymeleaf security-->
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity5</artifactId>
    <version>3.0.4.RELEASE</version>
</dependency>

<!--   mybatis、mysql、druid     -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.38</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.7</version>
</dependency>

<!--    kaptcha    -->
<dependency>
    <groupId>com.github.penggle</groupId>
    <artifactId>kaptcha</artifactId>
    <version>2.3.2</version>
</dependency>
```

#### config

> KaptchaConfig

```java
package com.changlu.springsecuritydemo3web.config;

import com.google.code.kaptcha.Producer;
import com.google.code.kaptcha.impl.DefaultKaptcha;
import com.google.code.kaptcha.util.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Properties;

/**
 * @ClassName KaptchaConfig
 * @Author ChangLu
 * @Date 3/23/2022 10:03 PM
 * @Description 验证码配置器
 */
@Configuration
public class KaptchaConfig {

    @Bean
    public Producer kaptcha() {
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width", "150");
        properties.setProperty("kaptcha.image.height", "50");
        properties.setProperty("kaptcha.textproducer.char.string", "0123456789");
        properties.setProperty("kaptcha.textproducer.char.length", "4");
        Config config = new Config(properties);
        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
        defaultKaptcha.setConfig(config);
        return defaultKaptcha;
    }

}
```

> WebMvcConfig

```java
package com.changlu.springsecuritydemo3web.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @ClassName WebMvcConfig
 * @Author ChangLu
 * @Date 3/23/2022 3:14 PM
 * @Description 自定义MVC配置器
 */
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/login.html").setViewName("login");
        registry.addViewController("/logout.html").setViewName("logout");
    }
}
```

> WebSecurityConfig

```java
package com.changlu.springsecuritydemo3web.config;

import com.changlu.springsecuritydemo3web.filter.KaptchaFilter;
import com.changlu.springsecuritydemo3web.service.MyUserDetailsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * @ClassName WebSecurity
 * @Author ChangLu
 * @Date 3/23/2022 3:10 PM
 * @Description 自定义Security配置
 */
@Configuration
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private MyUserDetailsService userDetailsService;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
//        1、自定义内存形式创建用户
//        final InMemoryUserDetailsManager userDetailsManager = new InMemoryUserDetailsManager();
//        userDetailsManager.createUser(User.withUsername("changlu").password("{noop}123").roles("admin","user").build());
        //2、自定义认证源来进行用户信息的获取
        auth.userDetailsService(userDetailsService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/login.html").permitAll()
                .antMatchers("/getVerifyCode").permitAll()
                .anyRequest().authenticated()
                .and()
                    .formLogin()
                    .loginPage("/login.html")  //要想走自己自定义登录页面的话，那么就必须在这里配置
//                        .loginProcessingUrl("/doLogin")
//                        .usernameParameter("uname")
//                        .passwordParameter("passwd")
//                    .defaultSuccessUrl("/logout.html",true) //登录成功后重定向到logout.html
                    .failureUrl("/login.html")  //redirct，异常信息保存在session作用域中
                .and()
                    .logout()
                        .logoutUrl("/logout")  //登录接口默认为/logout
                        .logoutSuccessUrl("/login.html")  //注销成功跳转url
                .and()
                .csrf().disable();

        //添加自定义验证码过滤器到校验用户名、密码过滤器前（其实at覆盖也可以，因为KaptchaFilter本身是继承UsernamePasswordAuthenticationFilter，
        // 并且在KaptchaFilter的attemptAuthentication中验证码通过就super.attemptAuthentication()了）
        http.addFilterBefore(kaptchaFilter(), UsernamePasswordAuthenticationFilter.class);
    }


    //配置KaptchaFilter
    @Bean
    public KaptchaFilter kaptchaFilter() throws Exception {
        KaptchaFilter kaptchaFilter = new KaptchaFilter();
        kaptchaFilter.setFilterProcessesUrl("/doLogin");//一定要指定请求路径，否则不会走过滤器
        //注意注意：若是自定义的这个filter不设置用户名、密码名称，其会走到katpcherfilter继承父类的认证中
        //通过debug发现，一旦kaptchaFilter其父类的用户名、密码认证完毕之后，后面的UsernamePasswordAuthenticationFilter不会再走一遍认证！！！
        //那么原本configure(http)那就可以不进行配置了用户名与密码名称了
        kaptchaFilter.setUsernameParameter("uname");
        kaptchaFilter.setPasswordParameter("passwd");
        kaptchaFilter.setAuthenticationManager(authenticationManager());//设置自定义认证管理器
        kaptchaFilter.setKaptchaParameter("kaptcha");//自定义获取验证码参数
        //设置认证成功处理器
        kaptchaFilter.setAuthenticationSuccessHandler((req,resp,auth)->{
            resp.sendRedirect("/logout.html");
        });
        //设置认证失败处理器，失败直接返回登录页面（若是该filter后面的过滤器报错也会走这边）
        kaptchaFilter.setAuthenticationFailureHandler((req,resp,ex)->{
            System.out.println("kaptcha ex:"+ ex.getMessage());
            resp.sendRedirect("/login.html");
        });
        return kaptchaFilter;
    }

    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
}
```

#### controller

> KaptchaController

```java
package com.changlu.springsecuritydemo3web.controller;

import com.google.code.kaptcha.Producer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.awt.image.BufferedImage;
import java.io.IOException;

/**
 * @ClassName KaptchaController
 * @Author ChangLu
 * @Date 3/23/2022 10:09 PM
 * @Description 验证码控制器
 */
@Controller
public class KaptchaController {

    @Autowired
    private Producer producer;

    @GetMapping("/getVerifyCode")
    public void getVerifyCode(HttpServletResponse response, HttpSession session) throws IOException {
        //1、创建验证码
        String text = producer.createText();
        //2、在session中存储验证码(或者redis中)
        session.setAttribute("kaptcha", text);
        //3、生成图片
        BufferedImage bufferedImage = producer.createImage(text);
        //4、响应图片
        response.setContentType("image/png");
        ServletOutputStream os = response.getOutputStream();
        ImageIO.write(bufferedImage,"jpg", os);//将生成的图片写入到流中。bufferedImage=>os
    }

}
```

> LoginController

```java
package com.changlu.springsecuritydemo3web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * @ClassName LoginController
 * @Author ChangLu
 * @Date 3/23/2022 3:08 PM
 * @Description 登录控制器
 */
@Controller
public class LoginController {

    @RequestMapping("/hello")
    @ResponseBody
    public String hello(){
        return "hello!";
    }

}
```

> UserController

```java
package com.changlu.springsecuritydemo3web.controller;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;


/**
 * @ClassName UserController
 * @Author ChangLu
 * @Date 3/23/2022 3:42 PM
 * @Description 用户控制器
 */
@Controller
public class UserController {

    @RequestMapping("/getUserInfo")
    @ResponseBody
    public Authentication getUserInfo(){
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication;
    }

}
```

#### dao

> UserDao

```java
package com.changlu.springsecuritydemo3web.dao;

import com.changlu.springsecuritydemo3web.entity.Role;
import com.changlu.springsecuritydemo3web.entity.User;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

/**
 * @ClassName UserDao
 * @Author ChangLu
 * @Date 3/23/2022 4:03 PM
 * @Description 用户Mapper
 */
@Mapper
public interface UserDao {
    //根据用户名查询用户
    User loadUserByUsername(String username);

    //根据用户id查询角色
    List<Role> getRolesByUid(Integer uid);
}
```



#### entity

> Role

```java
package com.changlu.springsecuritydemo3web.entity;

/**
 * @ClassName Role
 * @Author ChangLu
 * @Date 3/23/2022 4:02 PM
 * @Description 角色表
 */
public class Role {
    private Integer id;
    private String name;
    private String nameZh;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNameZh() {
        return nameZh;
    }

    public void setNameZh(String nameZh) {
        this.nameZh = nameZh;
    }
}
```

> User

```java
package com.changlu.springsecuritydemo3web.entity;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.*;

/**
 * @ClassName User
 * @Author ChangLu
 * @Date 3/23/2022 4:02 PM
 * @Description 用户表
 */
public class User  implements UserDetails {
    private Integer id;
    private String username;
    private String password;
    private Boolean enabled;
    private Boolean accountNonExpired;
    private Boolean accountNonLocked;
    private Boolean credentialsNonExpired;
    private List<Role> roles = new ArrayList<>();

    /**
     * 转换Role角色信息来对外统一提供
     * @return
     */
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        Set<GrantedAuthority> authorities = new HashSet<>(5);
        roles.forEach((role)->{
            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(role.getName());
            authorities.add(authority);
        });
        return authorities;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return accountNonExpired;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return credentialsNonExpired;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }


    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Boolean getEnabled() {
        return enabled;
    }

    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }

    public Boolean getAccountNonExpired() {
        return accountNonExpired;
    }

    public void setAccountNonExpired(Boolean accountNonExpired) {
        this.accountNonExpired = accountNonExpired;
    }

    public Boolean getAccountNonLocked() {
        return accountNonLocked;
    }

    public void setAccountNonLocked(Boolean accountNonLocked) {
        this.accountNonLocked = accountNonLocked;
    }

    public Boolean getCredentialsNonExpired() {
        return credentialsNonExpired;
    }

    public void setCredentialsNonExpired(Boolean credentialsNonExpired) {
        this.credentialsNonExpired = credentialsNonExpired;
    }

    public List<Role> getRoles() {
        return roles;
    }

    public void setRoles(List<Role> roles) {
        this.roles = roles;
    }
}
```

#### filter

> KaptchaFilter

```java
package com.changlu.springsecuritydemo3web.filter;

import com.changlu.springsecuritydemo3web.security.exception.KatchaNotMatchException;
import org.springframework.security.authentication.AuthenticationServiceException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.util.ObjectUtils;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @ClassName KaptchaFilter
 * @Author ChangLu
 * @Date 3/23/2022 10:06 PM
 * @Description 验证码过滤器
 */
public class KaptchaFilter extends UsernamePasswordAuthenticationFilter {

    public static final String SECURITY_FORM_KAPTCHA_KEY = "kaptcha";

    private String kaptchaParameter = SECURITY_FORM_KAPTCHA_KEY;

    public String getKaptchaParameter() {
        return kaptchaParameter;
    }

    public void setKaptchaParameter(String kaptchaParameter) {
        this.kaptchaParameter = kaptchaParameter;
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        if (!request.getMethod().equals("POST")) {
            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
        }
        //1、从请求中获取验证码
        String verifyCode = request.getParameter(this.getKaptchaParameter());
        //2、从session中获取验证码
        String sessionVerifyCode = (String) request.getSession().getAttribute("kaptcha");
        if (!ObjectUtils.isEmpty(sessionVerifyCode) && !ObjectUtils.isEmpty(verifyCode)  //两个验证码非空
            && verifyCode.equalsIgnoreCase(sessionVerifyCode)){   //两个验证码相等
            return super.attemptAuthentication(request, response);
        }
        //其他情况抛出异常
        throw new KatchaNotMatchException("验证码不匹配");
    }
}
```

#### exception

> KatchaNotMatchException

```java
package com.changlu.springsecuritydemo3web.security.exception;
import org.springframework.security.core.AuthenticationException;

/**
 * @ClassName KatchaNotMatchException
 * @Author ChangLu
 * @Date 3/23/2022 10:29 PM
 * @Description 自定义验证码异常
 */
public class KatchaNotMatchException extends AuthenticationException {

    public KatchaNotMatchException(String msg, Throwable cause){
        super(msg,cause);
    }

    public KatchaNotMatchException(String msg){
        super(msg);
    }

}
```

#### service

> MyUserDetailsService

```java
package com.changlu.springsecuritydemo3web.service;

import com.changlu.springsecuritydemo3web.dao.UserDao;
import com.changlu.springsecuritydemo3web.entity.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;

import javax.annotation.Resource;

/**
 * @ClassName MyUserDeatailService
 * @Author ChangLu
 * @Date 3/23/2022 3:51 PM
 * @Description 自定义认证用户
 */
@Service
public class MyUserDetailsService implements UserDetailsService {

    @Resource
    private UserDao userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //1、根据用户名创建用户对象
        User user = userMapper.loadUserByUsername(username);
        if(ObjectUtils.isEmpty(user))
            throw new UsernameNotFoundException("用户名不存在");
        //2、获取角色
        user.setRoles(userMapper.getRolesByUid(user.getId()));
        return user;
    }
}
```

#### resources/mapper

>  com/changlu/mapper

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.changlu.springsecuritydemo3web.dao.UserDao">
    <!--查询单个-->
    <select id="loadUserByUsername" resultType="User">
        select id,
               username,
               password,
               enabled,
               accountNonExpired,
               accountNonLocked,
               credentialsNonExpired
        from user
        where username = #{username}
    </select>

    <!--查询指定行数据-->
    <select id="getRolesByUid" resultType="Role">
        select r.id,
               r.name,
               r.name_zh nameZh
        from role r,
             user_role ur
        where r.id = ur.rid
          and ur.uid = #{uid}
    </select>
</mapper>
```

#### resources/templates

> login.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>登录页面</title>
</head>
<body>
    <h2>用户登录</h2>
    <form th:action="@{/doLogin}" method="post">
        用户名：<input type="text" name="uname"><br/>
        密码：<input type="text" name="passwd"><br/>
        验证码：<input type="text" name="kaptcha"><image th:src="@{/getVerifyCode}"></image><br/>
        <input type="submit" th:value="登录">
    </form>
    <h3>
        <!--    登录失败时的异常信息（由于使用的是redirect，所以异常信息要从session中取出来）    -->
        <div th:text="${session.SPRING_SECURITY_LAST_EXCEPTION}"></div>
    </h3>
</body>
</html>
```

>  logout.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <title>注销页面</title>
</head>
<body>
    <h1>欢迎 <span sec:authentication="principal.username"></span>,进入我的系统!</h1>
    <h3>用户信息信息:</h3>
    <!--  认证之后即可取出用户的数据信息  -->
    <ul>
        <li sec:authentication="principal.username"></li>
        <li sec:authentication="principal.authorities"></li>
        <li sec:authentication="principal.accountNonExpired"></li>
        <li sec:authentication="principal.accountNonLocked"></li>
        <li sec:authentication="principal.credentialsNonExpired"></li>
    </ul>
    <hr>
    <!-- 用于注销登录   -->
    <form th:action="@{/logout}" method="get" >
        <input type="submit" th:value="注销">
    </form>
</body>
</html>
```

# 四、前后端分离账号登录、注销（基于session）

## 完整demo

### 测试

> 说明

测试接口有4个：认证指的是请求带上cookie来在服务器进行校验身份

```
登录接口(无认证)：http://localhost:8083/doLogin
{
    "uname": "root",
    "passwd": "1223",
    "kaptcha": "4145"
}
获取验证码(无认证)：http://localhost:8083/getVerifyCode
获取用户信息(需认证)：http://localhost:8083/getUserInfo
注销登录(需认证)：http://localhost:8083/logout
```

![image-20220324150911181](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241509287.png)  

![image-20220324150928050](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241509139.png)  

> 测试

**①没有登录，直接访问用户信息**：http://localhost:8083/getUserInfo

效果：由于无cookie或者cookie无效，都会认证失败。

![image-20220324151406968](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241514046.png)  

**②获取验证码**：http://localhost:8083/getVerifyCode

效果：返回的是图片转Base64来编码的字符串，默认是采用JSON返回。

![image-20220324151453623](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241514720.png)  

一般前端想要将该图片显示，那么就需要将`data:image/png;base64,` + Base64编码字符串，才能够显示：

实时Base64转图片：https://tool.chinaz.com/tools/imgtobase

![image-20220324151744553](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241517636.png)  

之后就使用该验证码来访问。

**③登录接口：输入错误的验证码。**

![image-20220324151911159](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241519244.png)  

**④登录接口：输入错误的密码**。

![image-20220324152007349](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241520436.png)  

**⑤登录接口：验证码，用户名、密码都正确**。

![image-20220324152046099](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241520198.png)  

**⑥登录成功后，访问认证资源**。（此时cookie是有效的，在服务端session中存储着）

正常访问：

![image-20220324152149531](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241521616.png)  

**⑦注销登录**。（将session中的存储的认证信息删除）

![image-20220324152207050](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241522127.png)  

---

### 思路

自己实现一个Filter，该Filter继承了UsernamePasswordAuthenticationFilter，重写其中的认证逻辑，验证码与用户账号都在其中重写的方法中进行认证。

+ 本质登录方法依旧是走的UsernamePasswordAuthenticationFilter中给我们提供的，使用自定义的认证管理器以及自定义的认证数据源。

关于验证码：

![image-20220324155351505](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241553579.png)

+ 对于验证码请求与传统web不同的是：依旧是响应json字符串，所以自然不能直接返回直接返回图片，就需要将图片转为base64编码字符串来进行返回，之后让前端来进行拼接图片。

---

### 代码示例

其中红色标出来的在三中已经贴出代码了：

![image-20220324155902437](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203241559511.png)  

#### 配置

application.properties

```properties
# 服务器端口号
server.port=8083

# datasource
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/security?characterEncoding=UTF-8&useSSL=false
spring.datasource.username=root
spring.datasource.password=123456

# mybatis
mybatis.mapper-locations=classpath:com/changlu/mapper/*.xml
mybatis.type-aliases-package=com.changlu.springsecuritydemo03split.entity
# mybatis log开启
logging.level.com.changlu.springsecuritydemo03split=debug
```

pom.xml：springboot-boot-starter-parent 2.6.4

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!--    spring security    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!--   mybatis、mysql、druid     -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.38</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.7</version>
</dependency>

<!--    katpcha    -->
<dependency>
    <groupId>com.github.penggle</groupId>
    <artifactId>kaptcha</artifactId>
    <version>2.3.2</version>
</dependency>
```

#### config

> WebSecurity

```java
package com.changlu.springsecuritydemo03split.config;

import com.changlu.springsecuritydemo03split.security.filter.LoginFilter;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.OrRequestMatcher;
import org.springframework.util.ObjectUtils;

import java.util.HashMap;
import java.util.Map;

/**
 * @ClassName WebSecurity
 * @Author ChangLu
 * @Date 3/23/2022 4:39 PM
 * @Description 自定义Security配置
 */
@Configuration
public class WebSecurity extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService myUserDetailsService;


    //将LoginFilter暴露在工厂中：方便对其进行配置
    @Bean
    public LoginFilter loginFilter() throws Exception {
        LoginFilter loginFilter = new LoginFilter();
        loginFilter.setAuthenticationManager(authenticationManagerBean());//一定要在过滤器中显示设置自定义的认证管理器（否则报错authenticationManager must be specified）
        //设置登录接口的各项参数：url地址、用户名、密码
        loginFilter.setFilterProcessesUrl("/doLogin");
        loginFilter.setUsernameParameter("uname");
        loginFilter.setPasswordParameter("passwd");
        //登录成功执行器
        loginFilter.setAuthenticationSuccessHandler((req,resp,auth)->{
            Map<String,Object> result = new HashMap<>(3);
            result.put("msg","登录成功");
            result.put("code","200");
            result.put("authenication", auth);
            String json = new ObjectMapper().writeValueAsString(result);
            resp.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
            resp.getWriter().write(json);
        });
        loginFilter.setAuthenticationFailureHandler((req,resp,ex)->{
            Map<String,String> result = new HashMap<>(3);
            result.put("msg","登录失败");
            result.put("code","500");
            result.put("ex", ex.getMessage());
            String json = new ObjectMapper().writeValueAsString(result);
            resp.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
            resp.getWriter().write(json);
        });
        return loginFilter;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(myUserDetailsService);//注入自定义认证数据源
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/getVerifyCode").permitAll()  //放行验证码
                .anyRequest().authenticated()  //所有请求必须认证
                .and()
                    .formLogin() //前后端分离依旧走的是FormLogin，只不过使用的是自己定义的filter（继承UsernamePasswordAuthenticationFilter）
                .and()
                    //对于直接访问保护资源时出现的异常回调，默认是返回的登录页面；若是这里设置handler，则会返回自定义内容
                    .exceptionHandling()
                        .authenticationEntryPoint((req,resp,ex)->{
                            Map<String,String> result = new HashMap<>(3);
                            result.put("msg","请认证之后再访问");
                            result.put("code","500");
                            result.put("ex", ex.getMessage());
                            String json = new ObjectMapper().writeValueAsString(result);
                            resp.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
                            resp.getWriter().write(json);
                        })
                .and()
                .logout()
                    //定义logout的url（默认就是/logout）
                    .logoutUrl("/logout")
                    //定义logout的路径及方法（默认是/logout，Get）
                    .logoutRequestMatcher(new OrRequestMatcher(
                            new AntPathRequestMatcher("/logout", HttpMethod.DELETE.name()),
                            new AntPathRequestMatcher("/logout", HttpMethod.GET.name())
                    ))
                    //定义logout的成功执行器，进行JSON字符串响应
                    .logoutSuccessHandler((req,resp,auth)->{
                        Map<String,String> result = new HashMap<>(3);
                        result.put("msg","注销成功");
                        result.put("code","200");
                        if (!ObjectUtils.isEmpty(auth)){
                            result.put("注销用户", auth.getName());
                        }
                        String json = new ObjectMapper().writeValueAsString(result);
                        resp.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
                        resp.getWriter().write(json);
                    })
                .and()
                    .csrf().disable();

        //当前使用at：自定义的登录filter来替换UsernamePasswordAuthenticationFilter
        // at: 用来某个 filter 替换过滤器链中哪个 filter
        // before: 放在过滤器链中哪个 filter 之前
        // after: 放在过滤器链中那个 filter 之后
        http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);
    }


    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
```

#### controller

> KaptchaController

```java
package com.changlu.springsecuritydemo03split.controller;

import com.google.code.kaptcha.Producer;
import org.apache.tomcat.util.codec.binary.Base64;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.FastByteArrayOutputStream;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.imageio.ImageIO;
import javax.servlet.http.HttpSession;
import java.awt.image.BufferedImage;
import java.io.IOException;

/**
 * @ClassName KaptchaController
 * @Author ChangLu
 * @Date 3/24/2022 1:13 PM
 * @Description 验证码控制器
 */
@RestController
public class KaptchaController {
    private final Producer producer;

    @Autowired
    public KaptchaController(Producer producer) {
        this.producer = producer;
    }

    @GetMapping("/getVerifyCode")
    public String getVerifyCode(HttpSession session) throws IOException {
        //1、生成验证码
        String text = producer.createText();
        //2、存储到session中（或存储到redis里）
        session.setAttribute("kaptcha", text);
        //3、写入到内存中
        BufferedImage bi = producer.createImage(text);
        FastByteArrayOutputStream fbaos = new FastByteArrayOutputStream();
        ImageIO.write(bi, "png", fbaos);
        //4、生成Base64编码返回
        return Base64.encodeBase64String(fbaos.toByteArray());
    }
}
```

> LoginController

```java
package com.changlu.springsecuritydemo03split.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * @ClassName LoginController
 * @Author ChangLu
 * @Date 3/23/2022 4:43 PM
 * @Description 登录控制器
 */
@Controller
public class LoginController {

    //用于进行校验
    @RequestMapping("/hello")
    @ResponseBody
    public String hello(){
        return "hello";
    }

}
```

> UserController

```java
package com.changlu.springsecuritydemo03split.controller;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @ClassName UserController
 * @Author ChangLu
 * @Date 3/23/2022 6:13 PM
 * @Description 用户控制器
 */
@RestController
public class UserController {

    @GetMapping("/getUserInfo")
    public Authentication getUserInfo(){
       return SecurityContextHolder.getContext().getAuthentication();
    }

}
```

#### filter

> LoginFilter

```java
package com.changlu.springsecuritydemo03split.security.filter;

import com.changlu.springsecuritydemo03split.security.exception.KaptchaNotMatchException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.AuthenticationServiceException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.util.ObjectUtils;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

/**
 * @ClassName LoginFilter
 * @Author ChangLu
 * @Date 3/23/2022 4:45 PM
 * @Description 自定义前后端分离认证 Filter
 */
public class LoginFilter extends UsernamePasswordAuthenticationFilter {

    public static final String SECURITY_FORM_KAPTCHA_KEY = "kaptcha";

    private String kaptchaParameter = SECURITY_FORM_KAPTCHA_KEY;

    public String getKaptchaParameter() {
        return kaptchaParameter;
    }

    public void setKaptchaParameter(String kaptchaParameter) {
        this.kaptchaParameter = kaptchaParameter;
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        System.out.println("===========================");
        //1、判断是否是Post请求
        if (!request.getMethod().equals("POST")){
            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
        }
        //2、判断是否为JSON格式数据请求（即"application/json;charset=UTF-8"）
        if (request.getContentType().equalsIgnoreCase(MediaType.APPLICATION_JSON_VALUE)) {
            //3、从json数据中获取用户名与密码来进行认证：{"uname":"xxx","passwd":"xxx"}
            try {
                Map<String,String> userInfo = new ObjectMapper().readValue(request.getInputStream(), Map.class);
                String username = userInfo.get(getUsernameParameter());//通过这种方式取getUsernameParameter，好处是可以在外部自行定义名称
                String password = userInfo.get(getPasswordParameter());
                String verifyCode = userInfo.get(getKaptchaParameter());
                System.out.println("用户名：" + username + ",密码：" + password + ",验证码：" + verifyCode);
                String sessionVerifyCode = (String) request.getSession().getAttribute("kaptcha");//从session中获取到验证码
                //4、校验验证码是否正确
                if (!ObjectUtils.isEmpty(verifyCode) && !ObjectUtils.isEmpty(sessionVerifyCode) &&
                    verifyCode.equalsIgnoreCase(sessionVerifyCode)
                ){
                    UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, password);
                    setDetails(request, authenticationToken);//配置request身份信息(仿写父类调用的方法)
                    return this.getAuthenticationManager().authenticate(authenticationToken);//真正进行认证
                }
                throw new KaptchaNotMatchException("验证码有误");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //return super.attemptAuthentication(request,response);//尝试调用父类的认证方法
        //抛出异常
        throw new RuntimeException("请求类型有误,请确保类型为application/json;charset=UTF-8！");
    }
}
```

# 五、密码编码器自动升级

## 效果展示

数据库中原本password都是明文存储，让用户一登陆认证后就可以自动升级。

默认数据库状态：

![image-20220324202838682](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203242028751.png)    

依次登录三个账号后：

![image-20220324202751401](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203242027457.png)  

---

## 完整代码

标红的是之前使用的自定义数据源，在当前目录中不展示：

![image-20220324202924830](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/beifen-gitee/2022/202203242029899.png)  

自动升级前提：数据库密码必须是`{编码}xxx`方式存储，否则框架底层不会识别出来。

+ 在当前版本中默认升级编码为bcrypt。

### 配置

**application.properties**：

```java
server.port=8084

# datasource
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/security?characterEncoding=UTF-8&useSSL=false
spring.datasource.username=root
spring.datasource.password=123456

# mybatis
mybatis.mapper-locations=classpath:com/changlu/mapper/*.xml
mybatis.type-aliases-package=com.changlu.springsecuritydemo04encrypt.entity
# mybatis log开启
logging.level.com.changlu.springsecuritydemo04encrypt=debug
```

**pom.xml**：springboot-starter-parent 2.6.4

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!--    引入数据源依赖    -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.38</version>
</dependency>

<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
</dependency>

<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.8</version>
</dependency>
```

### service

> MyUserDetailService：要想实现自动升级，那么就需要实现UserDetailsPasswordService接口中的方法。

```java
package com.changlu.springsecuritydemo04encrypt.service;

import com.changlu.springsecuritydemo04encrypt.dao.UserDao;
import com.changlu.springsecuritydemo04encrypt.entity.Role;
import com.changlu.springsecuritydemo04encrypt.entity.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsPasswordService;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;

import javax.annotation.Resource;
import java.util.List;

/**
 * @ClassName MyUserDetailService
 * @Author ChangLu
 * @Date 3/24/2022 8:05 PM
 * @Description 自定义认证服务源、自动升级密码
 */
@Service
public class MyUserDetailService implements UserDetailsService, UserDetailsPasswordService {

    @Resource
    private UserDao userDao;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        final User user = userDao.loadUserByUsername(username);
        if (ObjectUtils.isEmpty(user)) {
            throw new UsernameNotFoundException("用户名不存在");
        }
        List<Role> roles = userDao.getRolesByUid(user.getId());
        user.setRoles(roles);
        return user;
    }

    @Override
    public UserDetails updatePassword(UserDetails user, String newPassword) {
        //1、更新密码
        final Integer status = userDao.updatePassword(user.getUsername(), newPassword);
        //2、若是更新成功，那么将内存中的用户进行更新密码
        if (status == 1){
            ((User)user).setPassword(newPassword);
        }
        return user;
    }


}
```

### config

> WebSecurity

```java
package com.changlu.springsecuritydemo04encrypt.config;

import com.changlu.springsecuritydemo04encrypt.service.MyUserDetailService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * @ClassName WebSecurity
 * @Author ChangLu
 * @Date 3/24/2022 5:36 PM
 * @Description 自定义security配置器
 */
@Configuration
public class WebSecurity extends WebSecurityConfigurerAdapter {


//    @Bean
//    public BCryptPasswordEncoder passwordEncoder(){
//        return new BCryptPasswordEncoder();
//    }

//    @Bean
//    @Override
//    public UserDetailsService userDetailsService(){
//        final InMemoryUserDetailsManager userDetailsManager = new InMemoryUserDetailsManager();
//        //方式一：动态方式
////        userDetailsManager.createUser(User.withUsername("changlu").password("{noop}123").roles("admin","user").build());
////        userDetailsManager.createUser(User.withUsername("admin").password("{bcrypt}$2a$10$Fsv9EcqNxlJH8ZMMLvUHfOfwc91DTeyUQVDsYSRAji0DpOv6/jFte").roles("admin","user").build());
//        //方式二：工厂注入BCryptPasswordEncoder+密码直接存加密之后的
//        userDetailsManager.createUser(User.withUsername("admin").password("$2a$10$Fsv9EcqNxlJH8ZMMLvUHfOfwc91DTeyUQVDsYSRAji0DpOv6/jFte").roles("admin","user").build());
//        return userDetailsManager;
//    }

    @Autowired
    private MyUserDetailService userDetailService;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and().formLogin()
                .and().csrf().disable();
    }

}
```

### controller

> HelloController：登录用于测试

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @ClassName HelloController
 * @Author ChangLu
 * @Date 3/24/2022 5:38 PM
 * @Description 测试
 */
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello(){
        return "hello";
    }

}
```

---

# 六、springsecurity集成JWT实现认证、授权

不通过springsecurity中的UsernamePasswordAuthenticationFilter来进行认证、校验。

## 效果展示

**目前测试接口如下**：仅仅只有登录接口是开放的，其他接口都需要认证及授权。

![image-20220326085037428](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260850497.png)  

测试内容：

```
1、测试/hello（不带token）
2、测试/hello（带上错误token）
3、登录接口
	输入正确用户名密码
	输入错误用户名密码
4、测试获取用户信息（带上正确token）
5、测试自定义权限校验接口（带上正确token）
6、测试注销登录（带上正确token）
7、注销登录后，带上之前token访问用户信息
```

1、测试/hello（不带token）

![image-20220326090252118](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260902204.png)  

2、测试/hello（带上错误token）

![image-20220326090318053](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260903132.png)  

3、登录接口
	输入正确用户名密码

![image-20220326090346093](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260903185.png)  

​	输入错误用户名密码

![image-20220326090357717](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260903801.png)  

4、测试获取用户信息（带上正确token）

![image-20220326090441960](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260904054.png)  

5、测试自定义权限校验接口（带上正确token）

自定义权限接口同样是自己定义的，就是校验一下当前用户是否具有sys:user:delete权限，很明显从之前的4中可以看到其不具备该权限

![image-20220326090537791](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260905867.png)  

![image-20220326090733424](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260907508.png)  

6、测试注销登录（带上正确token）

![image-20220326090816413](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260908493.png)  

7、注销登录后，带上之前token访问用户信息

![image-20220326090926900](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260909984.png)  

## sql

![image-20220326084532977](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260845045.png)  

```java
// 当前数据库用户、角色、菜单(权限)信息
用户：changlu、admin、test
角色：admin、user
权限：sys:user:add、sys:user:delete、sys:user:update、sys:user:query

用户与角色关系：
用户      角色
changlu  user
admin    admin
test     user

用户与权限关系：
用户      权限
changlu  sys:user:update、sys:user:query
admin    sys:user:add、sys:user:delete、sys:user:update、sys:user:query
test     sys:user:update、sys:user:query
```

```sql
# 建数据库
create database security-jwt;

# 使用数据库
use security-jwt;

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '菜单名',
  `path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '路由地址',
  `component` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '组件路径',
  `visible` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '#' COMMENT '菜单图标',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(11) NULL DEFAULT 0 COMMENT '是否删除（0未删除 1已删除）',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '菜单表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, 'NULL', NULL, NULL, '0', '0', 'sys:user:add', '#', NULL, NULL, NULL, NULL, 0, NULL);
INSERT INTO `sys_menu` VALUES (2, 'NULL', NULL, NULL, '0', '0', 'sys:user:delete', '#', NULL, NULL, NULL, NULL, 0, NULL);
INSERT INTO `sys_menu` VALUES (3, 'NULL', NULL, NULL, '0', '0', 'sys:user:update', '#', NULL, NULL, NULL, NULL, 0, NULL);
INSERT INTO `sys_menu` VALUES (4, 'NULL', NULL, NULL, '0', '0', 'sys:user:query', '#', NULL, NULL, NULL, NULL, 0, NULL);

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `role_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '角色权限字符串',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '角色状态（0正常 1停用）',
  `del_flag` int(1) NULL DEFAULT 0 COMMENT 'del_flag',
  `create_by` bigint(200) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(200) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '角色表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (1, 'admin', NULL, '0', 0, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `sys_role` VALUES (2, 'user', NULL, '0', 0, NULL, NULL, NULL, NULL, NULL);

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `menu_id` bigint(200) NOT NULL DEFAULT 0 COMMENT '菜单id',
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (1, 1);
INSERT INTO `sys_role_menu` VALUES (1, 2);
INSERT INTO `sys_role_menu` VALUES (1, 3);
INSERT INTO `sys_role_menu` VALUES (1, 4);
INSERT INTO `sys_role_menu` VALUES (2, 3);
INSERT INTO `sys_role_menu` VALUES (2, 4);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `user_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '1' COMMENT '用户类型（0管理员，1普通用户）',
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新人',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `del_flag` int(11) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1, 'changlu', 'NULL', '{noop}123', '0', NULL, NULL, NULL, NULL, '1', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (2, 'admin', 'NULL', '{noop}123', '0', NULL, NULL, NULL, NULL, '1', NULL, NULL, NULL, NULL, 0);
INSERT INTO `sys_user` VALUES (3, 'test', 'NULL', '{noop}123', '0', NULL, NULL, NULL, NULL, '1', NULL, NULL, NULL, NULL, 0);

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `role_id` bigint(200) NOT NULL DEFAULT 0 COMMENT '角色id',
  PRIMARY KEY (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (1, 2);
INSERT INTO `sys_user_role` VALUES (2, 1);
INSERT INTO `sys_user_role` VALUES (3, 2);

SET FOREIGN_KEY_CHECKS = 1;
```

---

## 项目结构

标红的是相对重要的其他它与之前有所重复：

![image-20220326091533490](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260915609.png)    

![image-20220326091617628](https://pictured-bed.oss-cn-beijing.aliyuncs.com/img/2022/3/202203260916712.png)  

### 配置

application.yml：

```yaml
server:
  port: 8088

spring:
  # 数据源
  datasource:
    url: jdbc:mysql://localhost:3306/security-jwt?characterEncoding=utf-8&serverTimezone=UTC
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver

#控制台打印sql(默认不会有打印sql语句)
mybatis-plus:
  mapper-locations: classpath:com/changlu/mapper/*.xml  # 指定xml路径
  type-aliases-package: com.changlu.springsecuritydemo05jwt.domain.pojo  #指定实体类路径
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

pom.xml：

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.6.5</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>

<!--   spring web starter     -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!--   spring security starter    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!--   lombok工具类     -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<!--redis依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!--fastjson依赖-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.33</version>
</dependency>
<!--jwt依赖-->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.0</version>
</dependency>

<!--   MyBatis-Plus starter     -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.3</version>
</dependency>
<!--    MySQL Driver    -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```

### config

> WebSecurity：自定义security配置

```java
package com.changlu.springsecuritydemo05jwt.config;

import com.changlu.springsecuritydemo05jwt.security.filter.JwtAuthenticationTokenFilter;
import com.changlu.springsecuritydemo05jwt.security.handler.AuthenticationEntryPointHandler;
import com.changlu.springsecuritydemo05jwt.security.handler.MyAccessDeniedHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.logout.LogoutFilter;
import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;

/**
 * @ClassName WebSecurity
 * @Author ChangLu
 * @Date 3/25/2022 11:00 AM
 * @Description 自定义security配置
 */
@Configuration
public class WebSecurity extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;//自定义认证数据源

    @Autowired
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;//自定义认证处理器

    @Autowired
    private AuthenticationEntryPointHandler authenticationEntryPointHandler;//处理未认证时执行处理器
    @Autowired
    private MyAccessDeniedHandler myAccessDeniedHandler;//处理为授权时执行处理器
    @Autowired
    private LogoutSuccessHandler logoutSuccessHandler;//处理注销成功执行器

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService);//配置自定义认证数据源
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(HttpMethod.POST, "/login").permitAll()  //放行登录接口
                .anyRequest().authenticated()
                .and()
                    .exceptionHandling()
                        .authenticationEntryPoint(authenticationEntryPointHandler)  //认证异常，默认返回403的HTTP请求
                        .accessDeniedHandler(myAccessDeniedHandler)  //授权异常，默认返回403的HTTP请求
                .and()
                    .logout().
                        logoutUrl("/logout").logoutSuccessHandler(logoutSuccessHandler)  //自定义注销成功处理器
                .and()
                    .csrf().disable()
                    //不通过Session获取SecurityContext（当前已经是前后端分离）
                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        //添加JWT认证过滤器
        http.addFilterBefore(jwtAuthenticationTokenFilter, LogoutFilter.class);

        //支持跨域
        http.cors();
    }

    //让AuthenicationManager从工厂中暴露出来
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
       return super.authenticationManagerBean();
    }
}
```

### Controller

```java
package com.changlu.springsecuritydemo05jwt.controller;

import com.changlu.springsecuritydemo05jwt.domain.ResponseResult;
import com.changlu.springsecuritydemo05jwt.domain.pojo.User;
import com.changlu.springsecuritydemo05jwt.service.LoginService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * @ClassName LoginController
 * @Author ChangLu
 * @Date 3/25/2022 2:44 PM
 * @Description 登录控制器
 */
@RestController
public class LoginController {

    @Autowired
    private LoginService loginService;

    @RequestMapping("/login")
    public ResponseResult login(@RequestBody User loginUser){
        return loginService.login(loginUser);
    }

//    方案一：自定义注销接口
//    @GetMapping("/logout")
//    public ResponseResult logout(){
//        return loginService.logout();
//    }
}
```

```java
package com.changlu.springsecuritydemo05jwt.controller;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @ClassName TestController
 * @Author ChangLu
 * @Date 3/25/2022 10:59 AM
 * @Description 测试控制器
 */
@RestController
public class TestController {

    //@PreAuthorize("hasAnyAuthority('sys:user:update')")
    @PreAuthorize("hasRole('sys:user:delete')")
    @GetMapping("/hello")
    public String hello(){
        return "hello";
    }

    //自定义权限
    @PreAuthorize("@ex.hasAuthority('sys:user:delete')")
    @GetMapping("/test")
    public String test(){
        return "test";
    }

}
```

```java
package com.changlu.springsecuritydemo05jwt.controller;

import com.changlu.springsecuritydemo05jwt.domain.ResponseResult;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * @ClassName UserController
 * @Author ChangLu
 * @Date 3/25/2022 6:10 PM
 * @Description 用户控制器
 */
@RestController
public class UserController {

    @GetMapping("/getUserInfo")
    public ResponseResult getUserInfo(){
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Map<String,Object> result = new HashMap<>(1);
        result.put("authentication", authentication);
        return new ResponseResult(200, result);
    }

}
```

### security

> express

```java
package com.changlu.springsecuritydemo05jwt.security.expression;

import com.changlu.springsecuritydemo05jwt.domain.LoginUser;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

/**
 * @ClassName SGExpressionRoot
 * @Author ChangLu
 * @Date 3/25/2022 9:44 PM
 * @Description 自定义权限
 */
@Component("ex")
public class SGExpressionRoot {

    public boolean hasAuthority(String authority){
        //1、获取当前用户的所有权限
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        //2、判断当前用户是否具备改权限进行访问
        return loginUser.getPermissions().contains(authority);
    }

}
```

> filter

```java
package com.changlu.springsecuritydemo05jwt.security.filter;

import com.changlu.springsecuritydemo05jwt.domain.LoginUser;
import com.changlu.springsecuritydemo05jwt.utils.JwtUtil;
import com.changlu.springsecuritydemo05jwt.utils.RedisCache;
import io.jsonwebtoken.Claims;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.util.ObjectUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @ClassName JwtAuthenticationFilter
 * @Author ChangLu
 * @Date 3/25/2022 3:33 PM
 * @Description 自定义认证过滤器
 */
@Component
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Autowired
    private RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //1、获取token
        String token = request.getHeader("token");
        if (ObjectUtils.isEmpty(token)) {
            filterChain.doFilter(request,response);//放行，当前未认证走到最后的拦截器会对其进行异常返回，走我们自己定义的认证失败处理器
            return;
        }
        //2、解析token，获取用户id
        String userId = null;
        try {
            Claims claims = JwtUtil.parseJWT(token);
            userId = claims.getSubject();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Token已失效或非法");
        }
        //3、从redis中获取用户信息
        LoginUser loginUser = redisCache.getCacheObject("login:" + userId);
        // 若是用户信息不存在，抛出异常重新登录
        if (ObjectUtils.isEmpty(loginUser)) {
            throw new RuntimeException("用户认证已失效，请重新登录");
        }
        //4、认证成功，存入SecurityContextHolder
        //注意这里使用了三个参数构造器，表示当前已经认证成功
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);
        filterChain.doFilter(request,response);
    }
}
```

> handler

```java
package com.changlu.springsecuritydemo05jwt.security.handler;

import com.alibaba.fastjson.JSON;
import com.changlu.springsecuritydemo05jwt.domain.ResponseResult;
import com.changlu.springsecuritydemo05jwt.utils.ServletUtils;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @ClassName AuthenticationEntryPointHandler
 * @Author ChangLu
 * @Date 3/25/2022 2:37 PM
 * @Description 自定义认证异常处理器（未认证，401）
 */
@Component
public class AuthenticationEntryPointHandler implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        ResponseResult<String> responseResult = new ResponseResult<>(HttpStatus.UNAUTHORIZED.value(), "当前未认证" + "，原因：" + authException.getMessage(), null);
        String json = JSON.toJSONString(responseResult);
        ServletUtils.renderString(response,json);
    }
}
```

```java
package com.changlu.springsecuritydemo05jwt.security.handler;

import com.alibaba.fastjson.JSON;
import com.changlu.springsecuritydemo05jwt.domain.LoginUser;
import com.changlu.springsecuritydemo05jwt.domain.ResponseResult;
import com.changlu.springsecuritydemo05jwt.utils.RedisCache;
import com.changlu.springsecuritydemo05jwt.utils.ServletUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;
import org.springframework.stereotype.Component;
import org.springframework.util.ObjectUtils;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @ClassName LogoutSuccessHandlerImpl
 * @Author ChangLu
 * @Date 3/25/2022 5:16 PM
 * @Description 注销成功处理器
 */

//方案二：自定义成功注销处理器
@Component
public class LogoutSuccessHandlerImpl implements LogoutSuccessHandler {

    @Autowired
    private RedisCache redisCache;

    @Override
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        //1、获取用户id
        if (!ObjectUtils.isEmpty(authentication)) {
            String userId = ((LoginUser) authentication.getPrincipal()).getUser().getId().toString();
            //2、根据用户id来删除redis存储的用户信息
            redisCache.deleteObject("login:" + userId);
        }
        ServletUtils.renderString(response, JSON.toJSONString(new ResponseResult(200, "注销成功！")));
    }
}
```

```java
package com.changlu.springsecuritydemo05jwt.security.handler;

import com.alibaba.fastjson.JSON;
import com.changlu.springsecuritydemo05jwt.domain.ResponseResult;
import com.changlu.springsecuritydemo05jwt.utils.ServletUtils;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @ClassName AccessDeniedHandlerImpl
 * @Author ChangLu
 * @Date 3/25/2022 7:27 PM
 * @Description 自定义授权异常执行器（未认证，403）
 */
@Component
public class MyAccessDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        ResponseResult responseResult = new ResponseResult(HttpStatus.FORBIDDEN.value(), "当前账号无权限访问");
        ServletUtils.renderString(response, JSON.toJSONString(responseResult));
    }
}
```

> service

```java
package com.changlu.springsecuritydemo05jwt.security.service;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.changlu.springsecuritydemo05jwt.domain.LoginUser;
import com.changlu.springsecuritydemo05jwt.domain.pojo.User;
import com.changlu.springsecuritydemo05jwt.mapper.MenuMapper;
import com.changlu.springsecuritydemo05jwt.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;

import javax.annotation.Resource;
import java.util.List;

/**
 * @ClassName UserDetailServiceImpl
 * @Author ChangLu
 * @Date 3/25/2022 2:01 PM
 * @Description 自定义认证数据源
 */
@Service
public class UserDetailServiceImpl implements UserDetailsService {

    @Resource
    private UserMapper userMapper;

    @Resource
    private MenuMapper menuMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //1、查询用户
        User user = userMapper.loadUserByUsername(username);
        //2、若是没有用户就抛出异常
        if (ObjectUtils.isEmpty(user)) {
            throw new UsernameNotFoundException("无该用户账号");
        }
        //3、若是查询到用户就去获取用户的权限，最后返回
        List<String> roles = menuMapper.selectPermsByUserId(user.getId());
        return new LoginUser(user,roles);
    }
}
```

### service

```java
package com.changlu.springsecuritydemo05jwt.service.impl;

import com.changlu.springsecuritydemo05jwt.domain.LoginUser;
import com.changlu.springsecuritydemo05jwt.domain.ResponseResult;
import com.changlu.springsecuritydemo05jwt.domain.pojo.User;
import com.changlu.springsecuritydemo05jwt.mapper.UserMapper;
import com.changlu.springsecuritydemo05jwt.service.LoginService;
import com.changlu.springsecuritydemo05jwt.utils.JwtUtil;
import com.changlu.springsecuritydemo05jwt.utils.RedisCache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;

import javax.annotation.Resource;
import java.util.HashMap;
import java.util.Map;

/**
 * @ClassName LoginServiceImpl
 * @Author ChangLu
 * @Date 3/25/2022 2:50 PM
 * @Description 登录业务处理器
 */
@Service
public class LoginServiceImpl implements LoginService {

    @Resource
    private UserMapper userMapper;

    @Autowired
    private RedisCache redisCache;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Override
    public ResponseResult login(User user) {
        //1、进行用户认证
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword());
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);
        //2、若是认证没有通过，抛出异常
        if (ObjectUtils.isEmpty(authenticate)) {
            throw new RuntimeException("用户认证失败");
        }
        //3、认证通过，将用户信息取出存储到redis
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();
        String userId = loginUser.getUser().getId().toString();
        redisCache.setCacheObject("login:" + userId, loginUser);
        //4、根据UserId来生成Token进行返回
        String token = JwtUtil.createJWT(userId);
        Map<String,String> result = new HashMap<>(1);
        result.put("token", token);
        return new ResponseResult(200, "登录成功", result);
    }

//    @Override
//    public ResponseResult logout() {
//        //1、通过SecurityContextHolder中获取用户id
//        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
//        String userId = ((LoginUser) authentication.getPrincipal()).getUser().getId().toString();
//        //2、根据用户id来删除redis存储的用户信息
//        redisCache.deleteObject("login:" + userId);
//        return new ResponseResult(200, "注销成功");
//    }
}
```

### mapper

MenuMapper：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.changlu.springsecuritydemo05jwt.mapper.MenuMapper">


    <select id="selectPermsByUserId" resultType="java.lang.String">
        SELECT
            distinct m.perms
        FROM
            sys_user_role ur
                LEFT JOIN sys_role r ON ur.role_id = r.id
                LEFT JOIN sys_role_menu rm ON r.id = rm.role_id
                LEFT JOIN sys_menu m ON rm.menu_id = m.id
        WHERE
            ur.user_id = #{userid}
          AND r.`status` = 0
          AND m.`status` = 0
    </select>


</mapper>
```

UserMapper：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.changlu.springsecuritydemo05jwt.mapper.UserMapper">

    <select id="loadUserByUsername" resultType="User">
        SELECT * from sys_user where user_name = #{username}
    </select>

</mapper>
```







---

整理者：长路  时间：2021.3.

